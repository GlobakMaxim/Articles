# Мой опыт работы с view слоем в большинстве архитектур

Сегодня я хочу поделиться болью от работы с view слоем в большинстве архитектур. А так же хочу еще раз напомнить об уже довольно популярном подходе к написанию данного слоя.  

Немного предыстории: Если не брать во внимание проекты с версткой UI  в `storyboard` и `xib`, то есть немалое количество проектов, где UI верстается прямо в `UIViewController`. Все это обусловливается тем, что `ViewController` - это такой `view` под прикрытием. Да, это хорошая идея, но которая имеет несколько «НО» которые я опишу ниже.

Одна из главных проблем, это разная верстка для iPad и iPhone. Однако и из этой проблемы есть достаточно простой выход - новый `ViewController`… специально созданный для iPad. И у этого подхода есть свои минусы. Например одинаковая логика элементов `ViewController` заставит дублировать код и нарушить принцип DRY.

Вторая проблема - сложная работа с состояниями экрана. 
Дело в том, что сейчас все приложения ходят в сеть и для лучшего UX должны поддерживать несколько состояний экрана, как минимум 4 - это состояние загрузки, ошибки, заполненное и пустое состояние. И как правило для каждого из них свой UI и view, а иначе у вас все будет в одном файле или классе, что в свою очередь испортит архитектуру и расширяемость объекта.

Для решение первой проблемы давайте вынесем все кастомные `view` за пределы контроллера, тогда у него останется одна основаная `view`, на которую можно будет добавлять другие кастомные элементы. 
```Swift
 final class HomeViewController: UIViewController {
 
  lazy var homeView: HomeView {
    let view = HomeView()
    ...
    return homeView
  }
  
  private func setupHomeView() {
    view.addSubview(homeView)
    homeView.layout(on: view) // Strech view on superview
  }
  
}
```

**Важно** Для более гибкого управления `view` можно вынести все UI компоненты наружу, например как `UITableViewCell`.  Это нам поможет лучше переиспользовать компонент для разных состояний. В качестве примера можно привести экран пустого состояния, который зачастую выглядит примерно так же как и экран ошибки, с небольшим отличием в цветах.

Еще можно использовать фабрику `HomeView`, которая будет определять девайс и возвращать уже нужное View, например `HomeViewForiPad`.
```Swift
final class HomeViewFabric {
  static func build() -> HomeView {
    switch deviceType {
      case iPhone: return HomeViewForiPhone()
      case iPad: return HomeViewForiPad()
    }
  }
}
```

В данном случае `HomeView` - протокол, который описывает интерфейс возвращаемой `view`. А уже в контроллере вы определяете поведение конкретных элементов. Например копирование название чего-либо по долгом нажатии на `UILabel`.

Мне нравится такой подход, ведь он сильно разгружает наш `ViewController`, которые мы запланировали использовать как `view`. Теперь контроллер действительно отвечает только за то, за что должен отвечать. А именно за контролирование показанной `view`. Мы также убираем достаточно большой кусок кода с позиционирование элементов (layout) в реализацию `view`.

Так же такой подход очень круто работает с `state machine`, где состояние экрана или модуля управляет отображаемой `view`. При этом состояние экрана не может управлять процессами, как это сделано в [`YARCH`](https://github.com/alfa-laboratory/YARCH) от Альфа Лаборатории, причем в данном кейсе наоборот, процессы управляют состоянием. В таком случае управление `view` выглядит следующим образом.
```Swift
enum HomeViewState {
  case loading
  case empty
  case error(Error)
  case success(Data)
}
  
var state = .loading {
  didSet { updateUI(for: state) }
}
  
private func updateUI(for state: HomeViewState) {
  switch state {
    case loading: setupLoadingView()
    case empty: setupEmptyView()
    case error(let error): setupErrorView(error)
    case success(let data): setupSuccessView(data)
  }
}
  
private func setupLoadingView() {
  removeSubviews(on: view) // Removee all subviews on view
  let loadingView = LoadingView()
  view.addSubview(loadingView)
  loadingView.layout(on: view)
}
  
private func setupEmptyView() { ... }
private func setupErrorView(_ error: Error) { ... }
private func setupSuccessView(_ data: Data) { ... }
```

Супер, мы получили много плюсов от этих двух подходов. Давайте на этой ноте подведем итоги   

1) Так как все `view` независимы друг от друга - мы легко можем добавлять и убирать новые состояния экрана и соответственно новые `view`

2) Мы можем легко добавлять и изменять `view` для разных размеров экранов и мы пишем логику обработку нажатий и вообще всех элементов только один раз, так как наши `view` для iPad и iPhone имеют одинаковый интерфейс.
  
3) Мы избавились от большого количества `layout` кода в контроллере и сам контроллер теперь занимается только своим делом.

P.S. Конечно это не серебряная пуля и у данного подхода есть свои недостатки, но со своей точки зрения я скажу, что мне часто облегчал работу. 

Всем удачи и удачного кодинга. 