# Мой опыт работы с view слоем в большинстве архитектур

Сегодня я хочу поделиться болью от работы с view слоем в большинстве архитектур. А так же хочу еще раз напомнить об уже довольно популярном подходе к написанию данного слоя.  

Немного предистории: Если не брать во внимание проекты с версткой UI  в `storyboard` и `xib`, то есть немалое количество проектов, где UI верстается прямо в UIViewController. Все это обусловливается, что ViewController - это такой view под прикрытием. Да, это хорошая идея, но которая имеет несколько «НО» которые я опишу ниже.

Одна из главных проблем, это разная верстка для iPad и iPhone. Однако и из этой проблемы есть достаточно простой выход - новый ViewController…специально созданный для iPad. И у этого подхода есть свои минусы. Например одинаковая логика элементов ViewController заставит дублировать код.

Вторая проблема - сложная работа с состояниями экрана. 
*Дополнить*

Для решение первой проблемы давайте вынесем все кастомные view за пределы контроллера,  тогда у контроллера останется одна основаная view, на которую можно будет добавлять другие кастомные view. 
```Swift
 final class HomeViewController: UIViewController {
 
  lazy var homeView: HomeView {
    let view = HomeView()
    ...
    return homeView
  }
  
  private func setupHomeView() {
    view.addSubview(homeView)
    homeView.layout(on: view) // Strech view on superview
  }
  
}
```

**Важно** Для более гибкого управление view можно вынести все UI компоненты наружу, например как `UITableViewCell`.  Это нам поможет лучше переиспользовать компонент для разных состояний. В качестве примера можно привести экран пустого состояния, который выглядит примерно так же как и экран ошибки, с небольшим отличием в цветах.

Еще можно использовать фабрику `HomeView`, которая будет определять девайс и возвращать уже нужное View, например `HomeViewForiPad`.
```Swift
final class HomeViewFabric {
  static func build() -> HomeView {
    switch deviceType {
      case iPhone: return HomeViewForiPhone()
      case iPad: return HomeViewForiPad()
    }
  }
}
```

В данном случае `HomeView` - протокол, который описывает интерфейс возвращаемой view. А уже в контроллере вы определяете поведение конкретных элементов. Например копирование название чего-либо по долгом нажатии на лейбл.

Мне нравится такой подход, ведь он сильно разгружает наш ViewController, которые мы запланировали использовать как view. Теперь контроллер действительно отвечает только за то, за что должен отвечать. А именно за контролирование показанной view. Мы так же убираем достаточно большой кусок кода с позиционирование элементов (layout) в реализацию view.

Так же такой подход очень круто работает с `state machine`, где состояние экрана или модуля управляет отображаемой view. При этом состояние экрана не может управлять процессам, как это сделано в `YARCH`, причем в данном кейсе наоборот, процессы управляют состоянием. В таком случае управление view выглядит следующим образом.
```Swift
enum HomeViewState {
  case loading
  case empty
  case error(Error)
  case success(Data)
}
  
var state = .loading {
  didSet { updateUI(for: state) }
}
  
private func updateUI(for state: HomeViewState) {
  switch state {
    case loading: setupLoadingView()
    case empty: setupEmptyView()
    case error(let error): setupErrorView(error)
    case success(let data): setupSuccessView(data)
  }
}
  
private func setupLoadingView() {
  removeSubviews(on: view) // Removee all subviews on view
  let loadingView = LoadingView()
  view.addSubview(loadingView)
  loadingView.layout(on: view)
}
  
private func setupEmptyView() { ... }
private func setupErrorView(_ error: Error) { ... }
private func setupSuccessView(_ data: Data) { ... }
```

Супер, мы получили много плюсов от этих двух подходов. Давайте на этой ноте подведем итоги   

1) Так как все view независимы друг от друга - мы легко можем добавлять и убирать новые состояния экрана и соответственно новые view

2) Мы можем легко добавлять и изменять view для разных размеров экранов и мы пишем логику обработку нажатий и вообще всех элементов только один раз, так как наши view для iPad и iPhone имеют одинаковый интерфейс.
  
3) Мы избавились от большого количества layout кода в контроллере и сам контроллер теперь занимается только своим делом.

P.S. Конечно это серебряная пуля и у данного подхода есть свои недостатки, но со своей точки зрения я скажу, что мне часто облегчал работу. 

Всем удачи и удачного кодинга. 
